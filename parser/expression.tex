% https://www.programiz.com/python-programming/precedence-associativity
% https://www.wscubetech.com/resources/python/precedence-associativity-operators
% https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-primary

% try<thing> looks ahead and tries to parse <thing>.
% if parsing was succesful:
	% sets \@pytexTMP@parserReturnValue to the parsed construct
	% consumes the parsed tokens
	% ends with \iftrue
% else,
	% leaves \@pytexTMP@parserReturnValue untouched
	% leaves tokens untouched
	% ends with \iffalse
% use \wrapif{\try<thing>}{<iftrue>}{<iffalse>} to avoid problems with ifs



% atom ::= identifier | literal | enclosure
% TODO: other literals, enclosures
\def\@pytexParser@tryAtom{%
	\@pytexParser@choice{\@pytexParser@tryToken{\tokentypeIDENTIFIER}}{\@pytexParser@tryToken{\tokentypeNUMBER}}%
}


% primary ::= atom | attributeref | subscription | slicing | call
% TODO: anything else than atom
\def\@pytexParser@tryPrimary{%
	\@pytexParser@tryAtom%
}

% await_expr ::= "await" primary
\def\@pytexParser@tryAwaitExpr{%
	\@pytexParser@join{\@pytexParser@tryToken{\tokentypeAWAIT}}{\@pytexParser@tryPrimary}{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@await\e{\second}}}%
}

% power ::= (await_expr | primary) ["**" u_expr]
\def\@pytexParser@tryPower{%
	\@pytexParser@joinOptional%
		{\@pytexParser@choice{\@pytexParser@tryAwaitExpr} {\@pytexParser@tryPrimary}} % (await_expr | primary)
		{\@pytexParser@join{\@pytexParser@tryToken{\tokentypeEXPONENTIATION}} {\@pytexParser@tryUExpr} {\let\@pytexTMP@parserReturnValue\second}} % ["**" u_expr]
		{\e\e\e\def\e\e\e\@pytexTMP@parserReturnValue\e\e\e{\e\e\e\@pytexOperator@pow\e\e\e{\e\first\e}\e{\second}}}%
}

% u_expr ::= power | "-" u_expr | "+" u_expr | "~" u_expr
\def\@pytexParser@tryUExpr{%
	\@pytexParser@choiceFour%
		{\@pytexParser@tryPower}% power
		{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeSUBTRACT}}{\@pytexParser@tryUExpr} % "-" u_expr
			{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@negate\e{\second}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeADD}}{\@pytexParser@tryUExpr} % "+" u_expr
			{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@pos\e{\second}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeINVERT}}{\@pytexParser@tryUExpr} % "~" u_expr
			{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@invert\e{\second}}}%
		}%
}

% m_expr ::= u_expr 
%		   | m_expr "*"  u_expr
%		   | m_expr "@"  m_expr  -> note: using 'm_expr "@" u_expr' instead, but like who cares
%		   | m_expr "//" u_expr
%		   | m_expr "/"  u_expr
%		   | m_expr "%"  u_expr
\def\@pytexParser@tryMExpr{%
	\wrapif{\@pytexParser@tryUExpr}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryMExprNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryMExprNext{% try to parse an operator and another u_expr
	\@pytexParser@choiceFive%
		{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeMULTIPLY}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@multiply\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeMATMULT}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@matmult\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeFLOORDIVIDE}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@floordivide\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeDIVIDE}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@divide\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeMODULO}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@modulo\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}%
		\def\next{\@pytexParser@tryMExprNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}


% a_expr ::= m_expr | a_expr "+" m_expr | a_expr "-" m_expr
\def\@pytexParser@tryAExpr{%
	\wrapif{\@pytexParser@tryMExpr}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryAExprNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryAExprNext{%
	\@pytexParser@choice%
		{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeADD}}{\@pytexParser@tryMExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@add\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeSUBTRACT}}{\@pytexParser@tryMExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@subtract\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}%
		\def\next{\@pytexParser@tryAExprNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}

\def\@pytexParser@expressionNine{ % operators '+' and '-'
	\@pytexParser@tryAExpr%
	\else%
		EXPECTED EXPRESSION!
	\fi%
}

\def\@pytexParser@expressionEight{% operators '>>' and '<<' TODO
	\@pytexParser@expressionNine%
}

\def\@pytexParser@expressionSeven{% operator '&' (bitwise and) TODO
	\@pytexParser@expressionEight%
}

\def\@pytexParser@expressionSix{% operator '^' (bitwise xor) TODO
	\@pytexParser@expressionSeven%
}
\def\@pytexParser@expressionFive{% operator '|' (bitwise or) TODO
	\@pytexParser@expressionSix%
}


% TODO: for now, we disallow associativity for these operators - but it is allow in python
\def\@pytexParser@expressionFour{% operators 'in', 'not in', 'is', 'is not', '<', '<=', '>', '>=', '==', '!='
	\@pytexLocal@begin{current}%

	\@pytexParser@expressionFive % left side of expression
	\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
	
	\ifmatch{\tokentypeIN} %
		\@pytexParser@expressionFive % right side of expression
		\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@in\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}} %
	\fi
	% TODO: not in
	\ifmatch{\tokentypeIS} %
		\@pytexParser@expressionFive % right side of expression
		\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@is\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}} %
	\fi
	% TODO: is not
	% TODO: <, <=, >, >=
	\ifmatch{\tokentypeEQUAL} % ==
		\@pytexParser@expressionFive % right side of expression
		\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@equal\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}} %
	\fi
	\ifmatch{\tokentypeNOTEQUAL} % !=
		\@pytexParser@expressionFive % right side of expression
		\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@notequal\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}} %
	\fi

	\e\def\e\@pytexTMP@parserReturnValue\e{\current} % return expr
	\@pytexLocal@end{current}%
}

\def\@pytexParser@expressionThree{ % operator 'not'
	% note: no need to use \current
	\ifmatch{\tokentypeNOT} % not
		\@pytexParser@expressionThree % right side of not
		\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@not\e{\@pytexTMP@parserReturnValue}} %
	\else %
		\@pytexParser@expressionFour % no not
	\fi %
}

\def\@pytexParser@expressionTwoNext{%
	\def\expressionTwoNext{\relax}%
	\ifmatch{\tokentypeAND} % and
		\@pytexParser@expressionThree % right side of expression
		\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@and\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}} %
		\def\expressionTwoNext{\@pytexParser@expressionTwoNext}%
	\fi %
	\expressionTwoNext %
}

\def\@pytexParser@expressionTwo{% operator 'and'
	\@pytexLocal@begin{current}%
	
	\@pytexParser@expressionThree % left side of expression
	\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
	
	\@pytexParser@expressionTwoNext%
	
	\e\def\e\@pytexTMP@parserReturnValue\e{\current} % return expr
	\@pytexLocal@end{current}%
}

\def\@pytexParser@expressionOneNext{%
	\def\expressionOneNext{\relax}%
	\ifmatch{\tokentypeOR}%
		\@pytexParser@expressionTwo % right side of expression
		\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@or\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}} %
		\def\expressionOneNext{\@pytexParser@expressionOneNext}%
	\fi%
	\expressionOneNext%
}

\def\@pytexParser@expressionOne{% operator 'or'
	\@pytexLocal@begin{current}%

	\@pytexParser@expressionTwo % left side of expression
	\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
	
	\@pytexParser@expressionOneNext%

	\e\def\e\@pytexTMP@parserReturnValue\e{\current} % return expr
	\@pytexLocal@end{current}%
}

\def\@pytexParser@expression{%
	\@pytexParser@expressionOne%
}
