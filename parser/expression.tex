% https://www.programiz.com/python-programming/precedence-associativity
% https://www.wscubetech.com/resources/python/precedence-associativity-operators
% https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-primary

% try<thing> looks ahead and tries to parse <thing>.
% if parsing was succesful:
	% sets \@pytexTMP@parserReturnValue to the parsed construct
	% consumes the parsed tokens
	% ends with \iftrue
% else,
	% leaves \@pytexTMP@parserReturnValue untouched
	% leaves tokens untouched
	% ends with \iffalse
% use \wrapif{\try<thing>}{<iftrue>}{<iffalse>} to avoid problems with ifs



% atom ::= identifier | literal | enclosure
% TODO: non number literals, enclosures
\def\@pytexParser@tryAtom{%
	\@pytexParser@choice{\@pytexParser@tryToken{\tokentypeIDENTIFIER}}{\@pytexParser@tryToken{\tokentypeNUMBER}}%
}


% primary ::= atom | attributeref | subscription | slicing | call
% TODO: anything else than atom
\def\@pytexParser@tryPrimary{%
	\@pytexParser@tryAtom%
}

% await_expr ::= "await" primary
\def\@pytexParser@tryAwaitExpr{%
	\@pytexParser@join{\@pytexParser@tryToken{\tokentypeAWAIT}}{\@pytexParser@tryPrimary}{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@await\e{\second}}}%
}

% power ::= (await_expr | primary) ["**" u_expr]
\def\@pytexParser@tryPower{%
	\@pytexParser@joinOptional%
		{\@pytexParser@choice{\@pytexParser@tryAwaitExpr} {\@pytexParser@tryPrimary}} % (await_expr | primary)
		{\@pytexParser@join{\@pytexParser@tryToken{\tokentypeEXPONENTIATION}} {\@pytexParser@tryUExpr} {\let\@pytexTMP@parserReturnValue\second}} % ["**" u_expr]
		{\e\e\e\def\e\e\e\@pytexTMP@parserReturnValue\e\e\e{\e\e\e\@pytexOperator@pow\e\e\e{\e\first\e}\e{\second}}}%
}

% u_expr ::= power | "-" u_expr | "+" u_expr | "~" u_expr
\def\@pytexParser@tryUExpr{%
	\@pytexParser@choiceFour%
		{\@pytexParser@tryPower}% power
		{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeSUBTRACT}}{\@pytexParser@tryUExpr} % "-" u_expr
			{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@negate\e{\second}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeADD}}{\@pytexParser@tryUExpr} % "+" u_expr
			{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@pos\e{\second}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeINVERT}}{\@pytexParser@tryUExpr} % "~" u_expr
			{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@invert\e{\second}}}%
		}%
}

% m_expr ::= u_expr 
%		   | m_expr "*"  u_expr
%		   | m_expr "@"  m_expr  -> note: using 'm_expr "@" u_expr' instead, but like who cares
%		   | m_expr "//" u_expr
%		   | m_expr "/"  u_expr
%		   | m_expr "%"  u_expr
\def\@pytexParser@tryMExpr{%
	\wrapif{\@pytexParser@tryUExpr}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryMExprNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryMExprNext{%
	\@pytexParser@choiceFive%
		{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeMULTIPLY}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@multiply\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeMATMULT}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@matmult\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeFLOORDIVIDE}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@floordivide\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeDIVIDE}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@divide\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeMODULO}}{\@pytexParser@tryUExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@modulo\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}%
		\def\next{\@pytexParser@tryMExprNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}


% a_expr ::= m_expr | a_expr "+" m_expr | a_expr "-" m_expr
\def\@pytexParser@tryAExpr{%
	\wrapif{\@pytexParser@tryMExpr}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryAExprNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryAExprNext{%
	\@pytexParser@choice%
		{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeADD}}{\@pytexParser@tryMExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@add\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeSUBTRACT}}{\@pytexParser@tryMExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@subtract\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}%
		\def\next{\@pytexParser@tryAExprNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}


% shift_expr ::= a_expr | shift_expr ("<<" | ">>") a_expr
\def\@pytexParser@tryShiftExpr{%
	\wrapif{\@pytexParser@tryAExpr}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryShiftExprNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryShiftExprNext{%
	\@pytexParser@choice%
		{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeSHIFTLEFT}}{\@pytexParser@tryAExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@shiftleft\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}{%
		\@pytexParser@join{\@pytexParser@tryToken{\tokentypeSHIFTRIGHT}}{\@pytexParser@tryAExpr}%
			{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@shiftright\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		}%
		\def\next{\@pytexParser@tryShiftExprNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}

% and_expr ::= shift_expr | and_expr "&" shift_expr
\def\@pytexParser@tryAndExpr{%
	\wrapif{\@pytexParser@tryShiftExpr}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryAndExprNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryAndExprNext{%
	\@pytexParser@join{\@pytexParser@tryToken{\tokentypeBITWISEAND}}{\@pytexParser@tryShiftExpr}%
		{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@bitwiseand\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		\def\next{\@pytexParser@tryAndExprNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}

% xor_expr ::= and_expr | xor_expr "^" and_expr
\def\@pytexParser@tryXorExpr{%
	\wrapif{\@pytexParser@tryAndExpr}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryXorExprNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryXorExprNext{%
	\@pytexParser@join{\@pytexParser@tryToken{\tokentypeBITWISEXOR}}{\@pytexParser@tryAndExpr}%
		{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@bitwisexor\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		\def\next{\@pytexParser@tryXorExprNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}

% or_expr  ::= xor_expr | or_expr "|" xor_expr
\def\@pytexParser@tryOrExpr{% TODO
	\wrapif{\@pytexParser@tryXorExpr}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryOrExprNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryOrExprNext{%
	\@pytexParser@join{\@pytexParser@tryToken{\tokentypeBITWISEOR}}{\@pytexParser@tryXorExpr}%
		{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@bitwiseor\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		\def\next{\@pytexParser@tryOrExprNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}

% comparison    ::= or_expr (comp_operator or_expr)*
% comp_operator ::= "<" | ">" | "==" | ">=" | "<=" | "!="
%                  | "is" ["not"] | ["not"] "in"
\def\@pytexParser@tryComparison{% TODO
	\@pytexParser@tryOrExpr%
}


% not_test ::= comparison | "not" not_test
\def\@pytexParser@tryNotTest{%
	\@pytexParser@choice{\@pytexParser@tryComparison}%
		{%
			\@pytesParser@join{\@pytexParser@tryToken{\tokentypeNOT}} {\@pytexParser@tryNotTest}%
				{\e\def\e\@pytexTMP@parserReturnValue\e{\e\@pytexOperator@not\e{\second}}}%
		}%
}

% and_test ::= not_test | and_test "and" not_test
\def\@pytexParser@tryAndTest{%
	\wrapif{\@pytexParser@tryNotTest}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryAndTestNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryAndTestNext{%
	\@pytexParser@join{\@pytexParser@tryToken{\tokentypeAND}}{\@pytexParser@tryNotTest}%
		{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@and\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		\def\next{\@pytexParser@tryAndTestNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}

% or_test  ::= and_test | or_test "or" and_test
\def\@pytexParser@tryOrTest{%
	\wrapif{\@pytexParser@tryAndTest}{%
		\@pytexLocal@begin{current}%
		\e\def\e\current\e{\@pytexTMP@parserReturnValue}%
		\@pytexParser@tryOrTestNext%
		\e\def\e\@pytexTMP@parserReturnValue\e{\current}%
		\@pytexLocal@end{current}%
		\def\ifresult{1}%
	}{%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}
\def\@pytexParser@tryOrTestNext{%
	\@pytexParser@join{\@pytexParser@tryToken{\tokentypeOR}}{\@pytexParser@tryAndTest}%
		{\e\e\e\def\e\e\e\current\e\e\e{\e\e\e\@pytexOperator@or\e\e\e{\e\current\e}\e{\@pytexTMP@parserReturnValue}}}%
		\def\next{\@pytexParser@tryOrTestNext}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}


% (extra) TODO: 
% 	assignment_expression  ::= [identifier ":="] expression
%   conditional_expression ::= or_test ["if" or_test "else" expression]
%	expression             ::= conditional_expression | lambda_expr




\def\@pytexParser@expression{%
	\@pytexParser@tryOrTest\else%
		EXPECTED EXPRESSION!
	\fi%
}
