
% token type enum
\def\tokentypeEND{0}
\def\enumnext#1{%
	\e\edef\csname tokentype#1\endcsname{\tokentypeEND}%
	\edef\tokentypeEND{\the\numexpr\tokentypeEND+1}%
}

\enumnext{NEWLINE}

\enumnext{IDENTIFIER}
\enumnext{NUMBER}

\enumnext{AND}
\enumnext{OR}
\enumnext{NOT}
\enumnext{IS}
\enumnext{ISNOT}
\enumnext{IN}
\enumnext{NOTIN}

\enumnext{EXPONENTIATION}
\enumnext{INVERT}
\enumnext{MULTIPLY}
\enumnext{MATMULT}
\enumnext{FLOORDIVIDE}
\enumnext{DIVIDE}
\enumnext{MODULO}

\enumnext{ADD}
\enumnext{SUBTRACT}
\enumnext{SHIFTLEFT}
\enumnext{SHIFTRIGHT}

\enumnext{BITWISEAND}
\enumnext{BITWISEOR}
\enumnext{BITWISEXOR}

\enumnext{EQUAL}
\enumnext{NOTEQUAL}
\enumnext{LESSTHAN}
\enumnext{LESSEQUAL}
\enumnext{GREATER}
\enumnext{GREATEREQUAL}

\enumnext{ASSIGN}

% keywords
\enumnext{AWAIT}
\enumnext{IF}
\enumnext{ELSE}
\enumnext{FOR}
\enumnext{PASS}
\enumnext{BREAK}
\enumnext{CONTINUE}
\enumnext{RETURN}

% other
\enumnext{COMMA}


% token macros - sets \toketype and, optionally, \tokenvalue
\def\@pytexToken@Newline{\edef\tokentype{\tokentypeNEWLINE}}
\def\@pytexToken@Identifier#1{\def\tokentype{\tokentypeIDENTIFIER}\def\tokenvalue{#1}}
\def\@pytexToken@Number#1{\def\tokentype{\tokentypeNUMBER}\def\tokenvalue{#1}}

\def\@pytexToken@and{\def\tokentype{\tokentypeAND}}
\def\@pytexToken@or{\def\tokentype{\tokentypeOR}}
\def\@pytexToken@in{\def\tokentype{\tokentypeIN}}
\def\@pytexToken@is{\def\tokentype{\tokentypeIS}}
\def\@pytexToken@not{\def\tokentype{\tokentypeNOT}}

\def\@pytexToken@Addition{\def\tokentype{\tokentypeADD}}
\def\@pytexToken@Subtraction{\def\tokentype{\tokentypeSUBTRACT}}
\def\@pytexToken@Multiplication{\def\tokentype{\tokentypeMULTIPLY}}
\def\@pytexToken@Division{\def\tokentype{\tokentypeDIVIDE}}
\def\@pytexToken@FloorDivision{\def\tokentype{\tokentypeFLOORDIVIDE}}
\def\@pytexToken@EqualTo{\def\tokentype{\tokentypeEQUAL}}
\def\@pytexToken@NotEqualTo{\def\tokentype{\tokentypeNOTEQUAL}}
\def\@pytexToken@Exponentiation{\def\tokentype{\tokentypeEXPONENTIATION}}
\def\@pytexToken@Modulo{\def\tokentype{\tokentypeMODULO}}

\def\@pytexToken@Assignment{\def\tokentype{\tokentypeASSIGN}}

\def\ifmatch#1{%
	\e\@pytexTokeniser@TokenList@getim\e{\currentidx}%
	\ifnum \tokentype = #1 %
		\edef\currentidx{\the\numexpr\currentidx+1}%
}
\def\ifpeek#1{%
	\e\@pytexTokeniser@TokenList@getim\e{\currentidx}%
	\ifnum \tokentype = #1 %
}



\def\currentidx{0}
\def\@pytexTMP@parserReturnValue{\undefined}
\@pytexStack@new{idxsavestack}
\@pytexStack@new{resultsavestack}

\def\savestate{%
	\e\idxsavestack@push\e{\currentidx}%
	\e\resultsavestack@push\e{\@pytexTMP@parserReturnValue}%
}
\def\restorestate{%
	\@pytexStack@pop{idxsavestack}{\currentidx}%
	\@pytexStack@pop{resultsavestack}{\@pytexTMP@parserReturnValue}%
}
\def\commitstate{%
	\@pytexStack@popd{idxsavestack}%
	\@pytexStack@popd{resultsavestack}%
}



% #1 = if, #2 = iftrue, #3 = iffalse
\def\wrapif#1#2#3{%
	#1 %
		#2 %
	\else %
		#3 %
	\fi %
}

% #1 = iftrue, #2 = if, #3 = iffalse
\def\wrapifsw#1#2#3{%
	#2 %
		#1 %
	\else %
		#3 %
	\fi %
}

% result ::= #1
\def\@pytexParser@tryToken#1{%
	\ifmatch{#1}%
		\e\def\e\@pytexTMP@parserReturnValue\e{\tokenvalue}%
}

% result ::= #1 | #2
\def\@pytexParser@choice#1#2{%
	\wrapif{#1}{%
		\def\ifresult{1}%
	}{%
		\wrapif{#2}{%
			\def\ifresult{1}%
		}{%
			\def\ifresult{0}%
		}%
	}%
	\ifnum\ifresult=1 %
}

% result ::= #1 | #2 | #3
\def\@pytexParser@choiceThree#1#2#3{%
	\@pytexParser@choice{#1}{\@pytexParser@choice{#2}{#3}}%
}

% result ::= #1 | #2 | #3 | #4
\def\@pytexParser@choiceFour#1#2#3#4{%
	\@pytexParser@choice{#1}{\@pytexParser@choiceThree{#2}{#3}{#4}}%
}

% result ::= #1 | #2 | #3 | #4 | #5
\def\@pytexParser@choiceFive#1#2#3#4#5{%
	\@pytexParser@choice{#1}{\@pytexParser@choiceFour{#2}{#3}{#4}{#5}}%
}

% result ::= #1 | #2 | #3 | #4 | #5 | #6
\def\@pytexParser@choiceSix#1#2#3#4#5#6{%
	\@pytexParser@choice{#1}{\@pytexParser@choiceFive{#2}{#3}{#4}{#5}{#6}}%
}


\def\@pytexParser@tryIdentifier{%
	\@pytexParser@tryToken{\tokentypeIDENTIFIER}%
		\e\def\e\@pytexTMP@parserReturnValue\e{\tokenvalue}%
}



% #1 = first thing, #2 = second thing, #3 = joining operation (results of #1 and #2 are in \first and \second)
% result ::= #1 #2
\def\@pytexParser@join#1#2#3{%
	\savestate%
	\wrapif{#1}{%
		\e\wrapifsw\e{%
			\e\def\e\first\e{\@pytexTMP@parserReturnValue}%
			\let\second\@pytexTMP@parserReturnValue%
			#3%
			\def\ifresult{1}%
			\commitstate%
		}{#2}{%
			\def\ifresult{0}%
			\restorestate%
		}%
	}{%
		\def\ifresult{0}%
		\restorestate%
	}%
	\ifnum\ifresult=1 %
}

% similar to \@pytexParser@join, but \@pytexTMP@parserReturnValue is automatically set to the return value of #1
\def\@pytexParser@joinFirst#1#2{%
	\savestate%
	\wrapif{#1}{%
		\e\wrapifsw\e{\e\def\e\@pytexTMP@parserReturnValue\e{\@pytexTMP@parserReturnValue}%
			\commitstate%
			\def\ifresult{1}%
		}{#2}{%
			\restorestate%
			\def\ifresult{0}%
		}%
	}{%
		\restorestate%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}

% similar to \@pytexParser@join, but \@pytexTMP@parserReturnValue is automatically set to the return value of #2
\def\@pytexParser@joinSecond#1#2{%
	\savestate%
	\wrapif{#1}{% TODO: this could mangle parserReturnValue
		\wrapif{#2}{%
			\commitstate%
			\def\ifresult{1}%
		}{%
			\restorestate%
			\def\ifresult{0}%
		}%
	}{%
		\restorestate%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}

% similar to \@pytexParser@join, but \@pytexTMP@parserReturnValue is set to #3 (given \@pytexTMP@parserReturnValue as result of #1)
\def\@pytexParser@joinFirstUnary#1#2#3{%
	\savestate%
	\wrapif{#1}{%
		\e\wrapifsw\e{%
			\e\def\e\@pytexTMP@parserReturnValue\e{\@pytexTMP@parserReturnValue}%
			#3%
			\commitstate%
			\def\ifresult{1}%
		}{#2}{%
			\restorestate%
			\def\ifresult{0}%
		}%
	}{%
		\restorestate%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}

% similar to \@pytexParser@join, but \@pytexTMP@parserReturnValue is set to #3 (given \@pytexTMP@parserReturnValue as result of #2)
\def\@pytexParser@joinSecondUnary#1#2#3{%
	\savestate%
	\wrapif{#1}{%
		\wrapif{#2}{%
			#3%
			\commitstate%
			\def\ifresult{1}%
		}{%
			\restorestate%
			\def\ifresult{0}%
		}%
	}{%
		\restorestate%
		\def\ifresult{0}%
	}%
	\ifnum\ifresult=1 %
}

% #1 = first thing, #2 = second thing, #3 = joining operation (provided with \first and \second), only executed when #2 is present
% result ::= #1 [#2]	-> {if(#2): #3}
\def\@pytexParser@joinOptional#1#2#3{%
	\savestate%
	\wrapif{#1}{%
		\e\wrapifsw\e{%
			\e\def\e\first\e{\@pytexTMP@parserReturnValue}%
			\let\second\@pytexTMP@parserReturnValue%
			#3%
			\def\ifresult{1}%
			\commitstate%
		}{#2}{%
			\def\ifresult{1}%
			\commitstate%
		}%
	}{%
		\def\ifresult{0}%
		\restorestate%
	}%
	\ifnum\ifresult=1 %
}





\input{parser/expression.tex}
\input{parser/simple_stmt.tex}












\def\@pytexParser@statementAssign{ %
	\@pytexLocal@begin{current}%
%
%	
%	
	\@pytexLocal@end{current}%
}

\def\@pytexParser@skipEmptyLines{%
	\ifmatch{\tokentypeNEWLINE}%
		\def\next{\@pytexParser@skipEmptyLines}%
	\else%
		\def\next{\relax}%
	\fi%
	\next%
}

\def\@pytexParser@statement{%
	\@pytexParser@skipEmptyLines%
	\wrapif{\@pytexParser@trySimpleStmt}{}%
	{%
		\let\@pytexTMP@parserReturnValue\undefined%
		EXPECTED SOMETHING!
	}%
}

\def\@pytexParser@parseNext{%
	\ifnum \@pytexTokeniser@TokenList@size > 0 %
		\@pytexParser@statement%
		%
		\show\@pytexTMP@parserReturnValue%
		%
		\def\next{\@pytexParser@parseNext}%
	\else %
		\def\next{\relax}%
	\fi %
	\next%
}

\def\@pytexParser@parse{
	\@pytexLocal@new{current}%
	\@pytexTokeniser@TokenList@peekim%
	\e\@pytexTokeniser@TokenList@push\e{\tokentypeEND}%
	
	\@pytexParser@parseNext%
	
	\let\@pytexTMP@parserReturnValue\undefined%
}




